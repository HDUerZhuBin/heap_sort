/*******************************************************************************************************************************
 * 堆排序
 * 堆满足如下两个条件：
 * 1.堆的逻辑结构是完全二叉树
 * 完全二叉树的性质中的父节点编号和字节点编号之间的关系（对应数组下标索引），使得完全二叉树这种逻辑结果可以使用数组进行存储
 * 2.堆中任意父节点中的数据都是大于字节点中的数据（大根堆，递归成立）
 * 堆排序就是使用条件2,每次调整构建出来的新的二叉堆，其堆顶都是当前最大值（对应大根堆），取出堆顶最大值，将剩余元素重新构建二叉堆，继续取出，放置在末尾，
 * 不断迭代，直到不需要构建二叉堆为止，得到的数组就是升序排列的数组
 * 
 * process:
 * 1.将待排序序列构建二叉堆并以数组形式存放;
 * 2.取出堆顶最大元素,并与当前数组的最后一个位置元素交换，这个时候就就完成了一趟排序，数组最后一个元素是有序的，前面元素无序;
 * 3.将前面无序元素组成的子序列（子数组）再次构建二叉堆，将堆顶元素（当前子序列/子数组最大元素，第二大元素）和当前子序列/子数组的最后一个元素进行交换，
 * 这时在数组中，最后一个元素是第一趟堆排序得到的最大值，倒数第二个元素是第二趟排序得到的次大值；
 * 4,不断迭代进行堆排序（假设原始序列共有N个元素，则需要进行N趟堆排序，不断迭代将堆顶最值元素输出），直到堆中元素个数为0,最后的得到是升序的序列
 * 
 * detail:
 * 1.由原始随机序列第一次得到二叉堆的数组结构（怎样在数组中进行位置交换操作）
 * 2.将堆顶元素和当前序列（数组）中的tail元素进行交换后，去除掉当前序列最后元素得到的子序列如何进行堆调整
 * 从底到顶不断进行迭代将最大值交换到堆顶端
 *******************************************************************************************************************************/
#ifndef __HEAPSORT_H__
#define __HEAPSORT_H__



#endif